/**
 * SCENARIO BUILDER v2 — Compositional scenario construction
 *
 * Builds scenarios from atomic components. No prebuilt dungeon or
 * party templates — everything is computed from encounter and member
 * selections.
 *
 * Usage:
 *   const { buildScenario } = require('./scenario-builder');
 *
 *   // Party visitor (4 members)
 *   const scenario = buildScenario({
 *     encounters: ['root-hollow', 'whispering-gallery', 'veil-breach'],
 *     members: ['knight', 'battlemage', 'cleric', 'rogue'],
 *   });
 *
 *   // Creature visitor
 *   const scenario = buildScenario({
 *     encounters: ['root-hollow', 'whispering-gallery', 'veil-breach'],
 *     creature: 'thornback-boar',
 *   });
 *
 *   // With per-encounter config overrides
 *   const scenario = buildScenario({
 *     encounters: ['honeyed-hollow', 'root-hollow', 'veil-breach'],
 *     creature: 'drift-symbiote',
 *     config: { bondThreshold: 12 },
 *     encounterConfigs: {
 *       'honeyed-hollow': { maxRounds: 8 },
 *     },
 *   });
 */

const registry = require('./registry');
const { buildDungeonTemplate, buildPartyTemplate, buildPartyDeck } = require('./template-builder');

// ═══════════════════════════════════════════════════════════════
// DEFAULTS
// ═══════════════════════════════════════════════════════════════

const DEFAULT_CONFIG = {
  bondThreshold: 12,
};

// ═══════════════════════════════════════════════════════════════
// NAMING
// ═══════════════════════════════════════════════════════════════

function generateName(dungeonTemplate, visitorName) {
  return `${dungeonTemplate.name} vs ${visitorName}`;
}

function generateDescription(encounterKeys) {
  const names = encounterKeys.map(k => registry.getEncounter(k).name);
  return `${names.join(' → ')}. Generated by composition engine.`;
}

// ═══════════════════════════════════════════════════════════════
// CORE BUILDER
// ═══════════════════════════════════════════════════════════════

/**
 * Build a scenario object compatible with the encounter engine.
 *
 * Provide EITHER `members` (4 member keys) for a party visitor,
 * OR `creature` (creature key) for a creature visitor. Not both.
 *
 * @param {object} spec
 * @param {string[]} spec.encounters - Exactly 3 encounter keys
 * @param {string[]} [spec.members] - 4 member keys (party visitor)
 * @param {string} [spec.creature] - Creature key (creature visitor)
 * @param {object} [spec.config={}] - Base config for all encounters
 * @param {object} [spec.encounterConfigs={}] - Per-encounter config overrides
 * @param {string} [spec.name] - Override auto-generated name
 * @param {string} [spec.description] - Override auto-generated description
 *
 * @returns {object} Scenario object for engine/sequence.js
 */
function buildScenario(spec) {
  // ── Validate encounters ──
  if (!Array.isArray(spec.encounters) || spec.encounters.length !== 3) {
    throw new Error(`buildScenario requires exactly 3 encounters, got ${spec.encounters?.length || 0}`);
  }

  const uniqueEnc = new Set(spec.encounters);
  if (uniqueEnc.size !== spec.encounters.length) {
    throw new Error(`Duplicate encounters not permitted: ${spec.encounters.join(', ')}`);
  }

  // ── Validate visitor (exactly one of members or creature) ──
  if (spec.members && spec.creature) {
    throw new Error('Provide either members (party) or creature, not both');
  }
  if (!spec.members && !spec.creature) {
    throw new Error('Provide either members (4 member keys) or creature (creature key)');
  }

  if (spec.members && spec.members.length !== 4) {
    throw new Error(`Party requires exactly 4 members, got ${spec.members.length}`);
  }

  const baseConfig = { ...DEFAULT_CONFIG, ...(spec.config || {}) };
  const encounterConfigs = spec.encounterConfigs || {};

  // ── Build dungeon template from encounters ──
  const dungeonTemplate = buildDungeonTemplate(spec.encounters);

  // ── Build visitor template + deck ──
  let visitorTemplate, visitorDeck, visitorName;

  if (spec.creature) {
    const creatureData = registry.getCreature(spec.creature);
    // Creature template for the engine: everything except the deck
    visitorTemplate = {
      name: creatureData.name,
      vitality: creatureData.vitality,
      resolve: creatureData.resolve,
      nerve: creatureData.nerve,
      trust: creatureData.trust,
      modifiers: creatureData.modifiers,
      motivation: creatureData.motivation,
      aiProfile: creatureData.aiProfile,
    };
    visitorDeck = creatureData.deck;
    visitorName = creatureData.name;
  } else {
    visitorTemplate = buildPartyTemplate(spec.members);
    visitorDeck = buildPartyDeck(spec.members);
    visitorName = visitorTemplate.name;
  }

  // ── Build encounter array ──
  const encounters = spec.encounters.map(encKey => {
    const encData = registry.getEncounter(encKey);
    const encOverrides = encounterConfigs[encKey] || {};
    const config = { ...baseConfig, ...encOverrides };

    return {
      encounter: {
        name: encData.name,
        description: encData.description,
        initiative: encData.initiative,
        autoEffects: encData.autoEffects,
        tags: encData.tags,
      },
      dungeonDeck: encData.deck,
      visitorDeck: visitorDeck,
      config: config,
    };
  });

  // ── Build scenario object ──
  return {
    name:            spec.name || generateName(dungeonTemplate, visitorName),
    description:     spec.description || generateDescription(spec.encounters),
    visitorTemplate: visitorTemplate,
    dungeonTemplate: dungeonTemplate,
    encounters:      encounters,
  };
}

/**
 * Build a scenario from a matchup spec (used by composition generator).
 *
 * @param {object} matchup - { encounters, members|creature, dungeonProfile, visitorProfile }
 * @param {object} [options] - { config, encounterConfigs }
 * @returns {object} Scenario object
 */
function buildFromMatchup(matchup, options = {}) {
  return buildScenario({
    encounters:      matchup.encounters,
    members:         matchup.members,
    creature:        matchup.creature,
    config:          options.config || {},
    encounterConfigs: options.encounterConfigs || {},
  });
}

module.exports = {
  buildScenario,
  buildFromMatchup,
  DEFAULT_CONFIG,
};